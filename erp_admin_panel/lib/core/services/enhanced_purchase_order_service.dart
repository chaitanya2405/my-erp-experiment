// Enhanced ERP System - Enhanced Purchase Order Service
// Provides intelligent purchase order management with automated reorder logic

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
// Using unified models instead of legacy imports
import '../../services/purchase_order_service.dart';
import '../../services/inventory_service.dart';
import '../events/erp_events.dart';
import '../events/erp_event_bus.dart';
import '../orchestration/transaction_orchestrator.dart';
import '../models/index.dart';
import 'enhanced_service_base.dart';

class EnhancedPurchaseOrderService extends EnhancedERPService 
    with TransactionCapable, RealTimeSyncCapable, AnalyticsCapable {
  
  static EnhancedPurchaseOrderService? _instance;
  final PurchaseOrderService _baseService = PurchaseOrderService();
  
  EnhancedPurchaseOrderService._(ERPEventBus eventBus, TransactionOrchestrator orchestrator)
      : super(eventBus, orchestrator);

  static EnhancedPurchaseOrderService getInstance(ERPEventBus eventBus, TransactionOrchestrator orchestrator) {
    _instance ??= EnhancedPurchaseOrderService._(eventBus, orchestrator);
    return _instance!;
  }

  @override
  Future<void> setupEventListeners() async {
    // Listen to low stock alerts for automatic reorder
    listenToEvent<LowStockAlertEvent>(_handleLowStockAlert);
    
    // Listen to inventory updates to track demand patterns
    listenToEvent<InventoryUpdatedEvent>(_trackDemandPatterns);
    
    // Listen to supplier updates
    listenToEvent<SupplierUpdatedEvent>(_handleSupplierUpdate);
    
    // Setup real-time sync
    setupRealTimeSync();
  }

  @override
  void listenToDataChanges() {
    // Listen to purchase order status changes
    listenToEvent<PurchaseOrderStatusChangedEvent>(_handlePOStatusChange);
  }

  /// Enhanced purchase order creation with business intelligence
  Future<String> createEnhancedPurchaseOrder({
    required String supplierId,
    required List<UnifiedPOLineItem> items,
    required String requestedBy,
    DateTime? expectedDeliveryDate,
    String priority = 'normal',
    bool autoGenerated = false,
    Map<String, dynamic> metadata = const {},
  }) async {
    return await executeInTransaction(
      'create_po_${DateTime.now().millisecondsSinceEpoch}',
      () async {
        // 1. Validate supplier and calculate totals
        final poData = await _preparePurchaseOrderData(supplierId, items);

        // 2. Generate PO number
        final poNumber = await _generatePONumber();

        // 3. Create purchase order using unified model
        final purchaseOrder = UnifiedPurchaseOrder(
          id: 'po_${DateTime.now().millisecondsSinceEpoch}',
          poId: poNumber,
          supplierId: supplierId,
          supplierName: poData['supplierName'] ?? 'Unknown Supplier',
          storeId: poData['storeId'] ?? 'default_store',
          createdBy: requestedBy,
          status: 'Draft',
          lineItems: items.map((item) => UnifiedPOLineItem(
            productId: item.productId,
            productName: item.productName,
            orderedQuantity: item.orderedQuantity,
            unitPrice: item.unitPrice,
            totalPrice: item.totalPrice,
            receivedQuantity: 0,
            expectedDelivery: expectedDeliveryDate ?? DateTime.now().add(const Duration(days: 7)),
          )).toList(),
          totalItems: items.length,
          totalValue: poData['totalAmount'] ?? 0.0,
          expectedDelivery: expectedDeliveryDate ?? DateTime.now().add(const Duration(days: 7)),
          deliveryStatus: 'Pending',
          billingAddress: poData['billingAddress'] ?? '',
          shippingAddress: poData['shippingAddress'] ?? '',
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
          metadata: {
            ...metadata,
            'priority': priority,
            'auto_generated': autoGenerated,
            'created_by_system': 'enhanced_erp',
          },
        );

        // 4. Save to database (convert to legacy format for now)
        // TODO: Update PurchaseOrderService to handle unified models
        await _baseService.createPurchaseOrder(purchaseOrder as dynamic);

        // 5. Emit purchase order created event
        emitEvent(PurchaseOrderCreatedEvent(
          eventId: 'po_created_${DateTime.now().millisecondsSinceEpoch}',
          source: 'EnhancedPurchaseOrderService',
          purchaseOrderId: purchaseOrder.id,
          supplierId: supplierId,
          items: items.map((item) => item.toMap()).toList(),
          totalAmount: poData['totalAmount'] ?? 0.0,
          priority: priority,
          metadata: {
            ...metadata,
            'po_number': poNumber,
            'expected_delivery': purchaseOrder.expectedDelivery?.toIso8601String(),
            'auto_generated': autoGenerated,
          },
        ));

        // 6. Track analytics
        _trackPurchaseOrderAnalytics(purchaseOrder, autoGenerated);

        debugPrint('‚úÖ Purchase Order created: $poNumber (${purchaseOrder.id})');
        return purchaseOrder.id;
      },
      affectedModules: ['purchase_orders', 'suppliers', 'analytics'],
      metadata: {
        ...metadata,
        'item_count': items.length,
        'auto_generated': autoGenerated,
      },
    );
  }

  /// Prepare purchase order data with validations and calculations
  Future<Map<String, dynamic>> _preparePurchaseOrderData(
    String supplierId, 
    List<UnifiedPOLineItem> items
  ) async {
    // TODO: Validate supplier exists
    // For now, return mock data
    double subtotal = 0.0;
    double taxAmount = 0.0;

    for (final item in items) {
      subtotal += item.totalPrice;
      taxAmount += item.totalPrice * 0.1; // 10% tax
    }

    final totalAmount = subtotal + taxAmount;

    return {
      'supplierName': 'Supplier $supplierId', // TODO: Get from supplier service
      'subtotal': subtotal,
      'taxAmount': taxAmount,
      'totalAmount': totalAmount,
    };
  }

  /// Generate sequential PO number
  Future<String> _generatePONumber() async {
    final timestamp = DateTime.now();
    return 'PO${timestamp.year}${timestamp.month.toString().padLeft(2, '0')}${timestamp.day.toString().padLeft(2, '0')}-${timestamp.millisecondsSinceEpoch.toString().substring(8)}';
  }

  /// Handle low stock alerts with automatic reorder logic
  Future<void> _handleLowStockAlert(LowStockAlertEvent event) async {
    debugPrint('üîÑ Processing automatic reorder for low stock: ${event.productId}');
    
    try {
      // Check if auto-reorder is enabled for this product
      final autoReorderEnabled = await _isAutoReorderEnabled(event.productId);
      if (!autoReorderEnabled) {
        debugPrint('‚è≠Ô∏è Auto-reorder disabled for product: ${event.productId}');
        return;
      }

      // Get optimal supplier and reorder quantity
      final reorderData = await _calculateOptimalReorder(event.productId, event.currentQuantity);
      if (reorderData == null) {
        debugPrint('‚ùå Could not calculate optimal reorder for: ${event.productId}');
        return;
      }

      // Create automatic purchase order
      final poId = await createEnhancedPurchaseOrder(
        supplierId: reorderData['supplierId'],
        items: [
          UnifiedPOLineItem(
            productId: event.productId,
            productName: reorderData['productName'],
            orderedQuantity: reorderData['reorderQuantity'],
            unitPrice: reorderData['unitPrice'],
            totalPrice: reorderData['reorderQuantity'] * reorderData['unitPrice'],
          ),
        ],
        requestedBy: 'system_auto_reorder',
        priority: event.currentQuantity == 0 ? 'urgent' : 'high',
        autoGenerated: true,
        metadata: {
          'trigger_event': 'low_stock_alert',
          'trigger_event_id': event.eventId,
          'current_quantity': event.currentQuantity,
          'minimum_quantity': event.minimumQuantity,
        },
      );

      // Emit auto reorder event
      emitEvent(AutoReorderTriggeredEvent(
        eventId: 'auto_reorder_${DateTime.now().millisecondsSinceEpoch}',
        source: 'EnhancedPurchaseOrderService',
        productId: event.productId,
        purchaseOrderId: poId,
        reorderQuantity: reorderData['reorderQuantity'],
        supplierId: reorderData['supplierId'],
        triggerEvent: event.eventId,
        metadata: {
          'algorithm': 'smart_reorder_v1',
          'confidence_score': reorderData['confidenceScore'],
        },
      ));

      debugPrint('‚úÖ Auto-reorder created: PO $poId for ${event.productId}');
    } catch (e) {
      debugPrint('‚ùå Auto-reorder failed for ${event.productId}: $e');
      
      emitEvent(AutoReorderFailedEvent(
        eventId: 'auto_reorder_failed_${DateTime.now().millisecondsSinceEpoch}',
        source: 'EnhancedPurchaseOrderService',
        productId: event.productId,
        errorMessage: e.toString(),
        triggerEvent: event.eventId,
      ));
    }
  }

  /// Check if auto-reorder is enabled for a product
  Future<bool> _isAutoReorderEnabled(String productId) async {
    // TODO: Check product configuration
    // For now, enable auto-reorder for all products
    return true;
  }

  /// Calculate optimal reorder quantity and supplier
  Future<Map<String, dynamic>?> _calculateOptimalReorder(String productId, int currentQuantity) async {
    try {
      // Get inventory record for target quantities
      final inventory = await InventoryService.getInventoryByProductId(productId);
      if (inventory == null) return null;

      // Calculate reorder quantity (using reorder point + safety stock as max)
      final maxStock = (inventory.reorderPoint.toInt() + inventory.safetyStockLevel.toInt()) * 2;
      final reorderQuantity = maxStock - currentQuantity;

      // TODO: Implement supplier selection logic
      // For now, use default supplier
      const defaultSupplierId = 'supplier_001';
      
      // TODO: Get product details and pricing
      const defaultUnitPrice = 10.0;
      const defaultProductName = 'Product';

      return {
        'supplierId': defaultSupplierId,
        'productName': '$defaultProductName $productId',
        'reorderQuantity': reorderQuantity,
        'unitPrice': defaultUnitPrice,
        'confidenceScore': 0.8, // Algorithm confidence
      };
    } catch (e) {
      debugPrint('Error calculating optimal reorder: $e');
      return null;
    }
  }

  /// Track demand patterns for intelligent forecasting
  Future<void> _trackDemandPatterns(InventoryUpdatedEvent event) async {
    if (event.reason == 'POS Sale') {
      // Track sales velocity for demand forecasting
      trackMetric('purchase_orders.demand_velocity', (event.previousQuantity - event.newQuantity).toDouble(), tags: {
        'product_id': event.productId,
        'location': event.location,
        'hour': DateTime.now().hour.toString(),
        'day_of_week': DateTime.now().weekday.toString(),
      });
    }
  }

  /// Handle supplier updates
  Future<void> _handleSupplierUpdate(SupplierUpdatedEvent event) async {
    debugPrint('üìã Supplier updated: ${event.supplierId}');
    // Could trigger price updates, lead time adjustments, etc.
  }

  /// Handle purchase order status changes
  Future<void> _handlePOStatusChange(PurchaseOrderStatusChangedEvent event) async {
    debugPrint('üìã PO status changed: ${event.purchaseOrderId} -> ${event.newStatus}');
    
    if (event.newStatus == 'received') {
      // Emit received event for inventory updates
      emitEvent(PurchaseOrderReceivedEvent(
        eventId: 'po_received_${DateTime.now().millisecondsSinceEpoch}',
        source: 'EnhancedPurchaseOrderService',
        purchaseOrderId: event.purchaseOrderId,
        supplierId: event.metadata['supplier_id'] ?? '',
        items: [], // TODO: Get from PO data
        receivedDate: DateTime.now(),
        metadata: event.metadata,
      ));
    }
  }

  /// Track purchase order analytics
  void _trackPurchaseOrderAnalytics(PurchaseOrder po, bool autoGenerated) {
    trackMetric('purchase_orders.created', 1.0, tags: {
      'supplier_id': po.supplierId,
      'auto_generated': autoGenerated.toString(),
      'priority': po.metadata['priority'] ?? 'normal',
    });

    trackMetric('purchase_orders.value', po.totalValue, tags: {
      'supplier_id': po.supplierId,
      'auto_generated': autoGenerated.toString(),
    });

    trackMetric('purchase_orders.items_count', po.lineItems.length.toDouble(), tags: {
      'supplier_id': po.supplierId,
    });
  }

  /// Get enhanced purchase order stream with analytics
  Stream<List<UnifiedPurchaseOrder>> getEnhancedPurchaseOrderStream() {
    return _baseService.poCollection.snapshots().map((snapshot) {
      return snapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        return UnifiedPurchaseOrder(
          id: doc.id,
          poId: data['po_number'] ?? '',
          supplierId: data['supplier_id'] ?? '',
          supplierName: data['supplier_name'] ?? '',
          storeId: data['store_id'] ?? 'default_store',
          createdBy: data['requested_by'] ?? 'system',
          status: data['status'] ?? 'Draft',
          lineItems: (data['items'] as List? ?? []).map((item) => UnifiedPOLineItem(
            productId: item['product_id'] ?? '',
            productName: item['product_name'] ?? '',
            orderedQuantity: item['quantity'] ?? 0,
            unitPrice: (item['unit_price'] ?? 0).toDouble(),
            totalPrice: (item['total_price'] ?? 0).toDouble(),
            receivedQuantity: item['received_quantity'] ?? 0,
          )).toList(),
          totalItems: (data['items'] as List? ?? []).length,
          totalValue: (data['total_amount'] ?? 0).toDouble(),
          expectedDelivery: data['expected_delivery_date'] != null 
              ? (data['expected_delivery_date'] as Timestamp).toDate() 
              : null,
          deliveryStatus: data['delivery_status'] ?? 'Pending',
          billingAddress: data['billing_address'] ?? '',
          shippingAddress: data['shipping_address'] ?? '',
          createdAt: data['order_date'] != null 
              ? (data['order_date'] as Timestamp).toDate() 
              : DateTime.now(),
          updatedAt: data['updated_at'] != null 
              ? (data['updated_at'] as Timestamp).toDate() 
              : DateTime.now(),
          metadata: Map<String, dynamic>.from(data['metadata'] ?? {}),
        );
      }).toList();
    });
  }


  double _calculateCompletionPercentage(UnifiedPurchaseOrder po) {
    if (po.lineItems.isEmpty) return 0.0;
    
    int totalOrdered = po.lineItems.fold(0, (sum, item) => sum + item.orderedQuantity);
    int totalReceived = po.lineItems.fold(0, (sum, item) => sum + item.receivedQuantity);
    
    return totalOrdered > 0 ? (totalReceived / totalOrdered) * 100 : 0.0;
  }

  /// Update purchase order status with event emission
  Future<void> updatePurchaseOrderStatus({
    required String purchaseOrderId,
    required String newStatus,
    required String changedBy,
    String? previousStatus,
    Map<String, dynamic> metadata = const {},
  }) async {
    await executeInTransaction(
      'update_po_status_${DateTime.now().millisecondsSinceEpoch}',
      () async {
        await _baseService.updatePurchaseOrder(purchaseOrderId, {
          'status': newStatus,
          'last_updated': DateTime.now(),
          'metadata': metadata,
        });

        emitEvent(PurchaseOrderStatusChangedEvent(
          eventId: 'po_status_${DateTime.now().millisecondsSinceEpoch}',
          source: 'EnhancedPurchaseOrderService',
          purchaseOrderId: purchaseOrderId,
          previousStatus: previousStatus ?? 'Unknown',
          newStatus: newStatus,
          changedBy: changedBy,
          metadata: metadata,
        ));

        trackMetric('purchase_orders.status_change', 1.0, tags: {
          'new_status': newStatus,
          'po_id': purchaseOrderId,
        });
      },
      affectedModules: ['purchase_orders', 'analytics'],
      metadata: metadata,
    );
  }

  /// Receive purchase order with inventory updates
  Future<void> receivePurchaseOrder({
    required String purchaseOrderId,
    required List<UnifiedReceivedItem> receivedItems,
    required String receivedBy,
    Map<String, dynamic> metadata = const {},
  }) async {
    await executeInTransaction(
      'receive_po_${DateTime.now().millisecondsSinceEpoch}',
      () async {
        // Update PO status
        await updatePurchaseOrderStatus(
          purchaseOrderId: purchaseOrderId,
          newStatus: 'received',
          changedBy: receivedBy,
          metadata: {
            ...metadata,
            'received_by': receivedBy,
            'received_date': DateTime.now().toIso8601String(),
          },
        );

        // Emit PO received event (will trigger inventory updates)
        emitEvent(PurchaseOrderReceivedEvent(
          eventId: 'po_received_${DateTime.now().millisecondsSinceEpoch}',
          source: 'EnhancedPurchaseOrderService',
          purchaseOrderId: purchaseOrderId,
          supplierId: metadata['supplier_id'] ?? '',
          items: receivedItems.map((item) => item.toMap()).toList(),
          receivedDate: DateTime.now(),
          metadata: metadata,
        ));

        debugPrint('‚úÖ Purchase Order received: $purchaseOrderId');
      },
      affectedModules: ['purchase_orders', 'inventory', 'analytics'],
      metadata: metadata,
    );
  }
}
